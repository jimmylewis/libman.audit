namespace Libman.Audit;

public class VulnerabilityAnalyzer : IVulnerabilityAnalyzer
{
    private readonly IGitHubAdvisoryClient _advisoryClient;
    private readonly ILogger _logger;
    
    private readonly Dictionary<string, int> _severityRanking = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)
    {
        { "Critical", 4 },
        { "High", 3 },
        { "Medium", 2 },
        { "Low", 1 },
        { "Unknown", 0 }
    };

    public VulnerabilityAnalyzer(IGitHubAdvisoryClient advisoryClient, ILogger logger)
    {
        _advisoryClient = advisoryClient;
        _logger = logger;
    }

    public async Task<List<VulnerablePackage>> AnalyzePackagesAsync(List<LibmanPackage> packages)
    {
        Dictionary<string, VulnerablePackage> packageVulnerabilities = new Dictionary<string, VulnerablePackage>();

        try
        {
            foreach (LibmanPackage package in packages)
            {
                AdvisoryResult result = await _advisoryClient.GetAdvisoriesAsync(package.Name, package.Version);

                // If there's a warning, log it
                if (result.HasWarning)
                {
                    _logger.LogWarning(result.Warning!);
                }

                // Then use result.Advisories instead of advisories
                if (result.Advisories.Count > 0)
                {
                    // Create a unique key for this package
                    string packageKey = $"{package.Name}|{package.Version}|{package.Provider}";

                    // Get or create an entry for this package
                    if (!packageVulnerabilities.TryGetValue(packageKey, out VulnerablePackage? vulnerablePackage))
                    {
                        vulnerablePackage = new VulnerablePackage
                        {
                            Name = package.Name,
                            Version = package.Version,
                            Provider = package.Provider,
                            VulnerabilityCount = 0,
                            Description = string.Empty,
                            Severity = string.Empty
                        };
                        packageVulnerabilities.Add(packageKey, vulnerablePackage);
                    }

                    // Update total vulnerability count
                    vulnerablePackage.VulnerabilityCount = result.Advisories.Count;

                    // Count occurrences of each severity level and find maximum severity
                    Dictionary<string, int> severityCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                    string maxSeverity = "Unknown";
                    int maxRank = 0;

                    foreach (GitHubAdvisory advisory in result.Advisories)
                    {
                        string severity = string.IsNullOrEmpty(advisory.Severity) ? "Unknown" : advisory.Severity;
                        
                        // Count severity
                        if (severityCounts.ContainsKey(severity))
                        {
                            severityCounts[severity]++;
                        }
                        else
                        {
                            severityCounts[severity] = 1;
                        }

                        // Track maximum severity
                        if (_severityRanking.TryGetValue(severity, out int rank))
                        {
                            if (rank > maxRank)
                            {
                                maxRank = rank;
                                maxSeverity = severity;
                            }
                        }
                    }

                    // Create a summary description
                    List<string> severitySummaries = new List<string>();
                    foreach (KeyValuePair<string, int> severityCount in severityCounts)
                    {
                        severitySummaries.Add($"{severityCount.Value} {severityCount.Key}");
                    }
                    vulnerablePackage.Description = string.Join(", ", severitySummaries);

                    // Set the maximum severity
                    vulnerablePackage.Severity = maxSeverity;
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning($"Error checking for vulnerabilities: {ex.Message}");
        }

        return packageVulnerabilities.Values.ToList();
    }
}
